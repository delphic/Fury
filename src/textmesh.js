// Simple single line text mesh using Atlas
// Broadly similar to tilemap, however supports varying position based on custom tile widths
// Prefabs generated by Atlas do not adjust for variable width so there is unnecessary blending / overdraw

const Atlas = require('./atlas');
const { vec3 } = require('./maths');

module.exports = (function(){
	let exports = {};

	let Alignment = exports.Alignment = {
		"left": 0,
		"center": 1,
		"right": 2
	};

	let atlasWidths = {};

	let generateCharWidthLookup = (atlas) => {
		let lookup = {};
		if (hasVariableTileWidths(atlas)) {
			for (let i = 0, l = atlas.customTileWidths.length; i < l; i++) {
				let { width, tiles } = atlas.customTileWidths[i];
				for (let j = 0, n = tiles.length; j < n; j++) {
					lookup[tiles[j]] = width;
				}
			}
		} 
		atlasWidths[atlas.id] = lookup;
	};

	let hasVariableTileWidths = exports.hasVariableTileWidths = (atlas) => {
		return atlas.customTileWidths && atlas.customTileWidths.length;
	};

	let getCharWidth = exports.getCharWidth = (atlas, char) => {
		let tileWidth = atlas.tileWidth;
		let lookup = atlasWidths[atlas.id];
		if (lookup && lookup[char] !== undefined) {
			tileWidth = lookup[char];
		}
		return tileWidth;
	};

	exports.create = (config) => {
		let { text, scene, atlas, position, alignment, color, gridClamp } = config;

		if (!atlasWidths[atlas.id]) {
			generateCharWidthLookup(atlas);
		}

		let tiles = [];

		let textMesh = {};
		textMesh.remove = () => {
			for (let i = 0, l = tiles.length; i < l; i++) {
				scene.remove(tiles[i]);
			}
			tiles.length = 0;
		};

		let calculateWidth = textMesh.calculateWidth = (text) => {
			let width = 0;
			if (hasVariableTileWidths(atlas)) {
				for (let i = 0, l = text.length; i < l; i++) {
					width += getCharWidth(atlas, text[i]);
				}
			} else {
				width = text.length * atlas.tileWidth;
			}
			return width;
		};

		textMesh.getText = () => text;
		textMesh.setText = (value) => {
			textMesh.remove();

			let offset = 0;
			if (alignment == Alignment.center) {
				if (gridClamp && !hasVariableTileWidths(atlas)) {
					offset = Math.floor(text.length / 2) * atlas.tileWidth;
				} else {
					offset = Math.floor(calculateWidth(value) / 2);
				}
			} else if (alignment == Alignment.right) {
				offset = calculateWidth(value);
			}
			
			let x = position[0] - offset, y = position[1], z = position[2];
			for (let i = 0, l = value.length; i < l; i++) {
				let char = value[i];
				let name = Atlas.createTilePrefab({ atlas: atlas, tile: char, color: color });
				tiles.push(scene.instantiate({
					name: name,
					position: vec3.fromValues(x, y, z)
				}));
				x += getCharWidth(atlas, char);
			}
			text = value;
		};

		textMesh.setText(text);

		return textMesh;
	};

	return exports;
})();